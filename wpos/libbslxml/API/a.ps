%!PS
%%Title: class XmlConfig
%%Creator: html2ps version 1.0 beta3
%%EndComments
save
2000 dict begin
/d {bind def} bind def
/D {def} d
/t true D
/f false D
/FL [/Times-Roman
/Times-Italic
/Times-Bold
/Times-BoldItalic
/Courier
/Courier-Oblique
/Courier-Bold
/Courier-BoldOblique
/Helvetica
/Helvetica-Oblique
/Helvetica-Bold
/Helvetica-BoldOblique] D
/WF t D
/WI 0 D
/F 1 D
/IW 454 F div D
/IL 672 F div D
/PS 842 D
/EF [0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 2 2] D
/EZ [11 9 19 17 15 13 12 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 8 8] D
/Ey [0 0 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] D
/EG [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1] D
/Tm [1 1 0.8 0.8 0.8 0.8 0.8 0.8 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1.3 0 0] D
/Bm [1 1 0.5 0.5 0.5 0.5 0.5 0.5 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1 0 0] D
/Lm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 2 0 0 0] D
/Rm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0] D
/EU [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0 0] D
/NO f D
/YY [[{()}1][{()}0][{()}2]] D
/ZZ [[{()}1][{()}0][{()}2]] D
/Ts EZ 0 get D
/TU f D
/Xp t D
/AU f D
/SN 0 D
/Cf f D
/Tp f D
/Fe f D
/TI 1 Ts mul D
/Fm 14 D
/xL 71 D
/xR 71 D
/yL 757 D
/yR 757 D
/Wl 454 F div D
/Wr 454 F div D
/hL 672 F div D
/hR 672 F div D
/FE {newpath Fm neg Fm M CP BB IW Fm add Fm L IW Fm add IL Fm add neg L CP BB
 Fm neg IL Fm add neg L closepath} D
/LA {PM 0 eq{/IW Wl D /IL hL D}{/IW Wr D /IL hR D}ie /W IW D /LL W D /LS W D
 /LE IL D TU PM 0 eq and{IW 56 F div add SA{Sf div}if 0 translate}
 {PM 0 eq{xL yL}{xR yR}ie translate F SA{Sf mul}if dup scale
 CS CF FS Cf{CA CL get VC}if /Bb f D}ie 0 0 M
 TF not Tc or {Cf{gsave SA{1 Sf div dup scale}if Cb VC FE fill grestore}if}if}D
/Pi 0 Ts mul D
/SG [0.8 1 1] D
/Ab 15 D
/J 0 D
/Tc f D
/NH 6 D
/Nf f D
/Pa f D
/LH 1.2 D
/XR f D
/Xr {/pN E D ( [p ) WB pN WB (] )WB} D
/Db [16#FF 16#FF 16#FF] D
/Dt [16#00 16#00 16#00] D
/eA f D
/Fi f D
/bT f D
/Lc t D
/Dl [16#00 16#00 16#00] D
/LX f D
/Br 0.25 D
/IA ([IMAGE]) D
/DS {/PF f D()WB NL NP()pop RC ZF} D
/Gb f D
/Mb t D
/Hc [16#00 16#00 16#00] D
/Bl 3 D
/MI -15.2 D
/DX (DRAFT) D
/Di 0 D
/Tt 113.385826771654 D
/Th {()2 Al()BR (
      ) 0 1 -1 H()4 FZ Ti ES()EH (
      ) 0 2 -1 H() ME 0 get join EH()Ea()BR()} D
/tH {()0 1 -1 H (Table of Contents) EH()} D
/FD 2 D
/Dy 2 D
/cD [16#F0 16#F0 16#F0] D
/FW 0.6 D
/FU [16#00 16#00 16#00] D
/ET {/RM f D /A0 0 D /PN SN D /OU t D /Ou t D /W IW D /LL W D D1
 Ms not TP and{Ip}if /TF f D} D

%-- End of variable part --
/MySymbol 10 dict dup begin
 /FontType 3 D /FontMatrix [.001 0 0 .001 0 0 ] D /FontBBox [25 -10 600 600] D
 /Encoding 256 array D 0 1 255{Encoding exch /.notdef put}for
 Encoding (e) 0 get /euro put
 /Metrics 2 dict D Metrics begin
  /.notdef 0 D
  /euro 651 D
 end
 /BBox 2 dict D BBox begin
  /.notdef [0 0 0 0] D
  /euro [25 -10 600 600] D
 end
 /CharacterDefs 2 dict D CharacterDefs begin
  /.notdef {} D
  /euro{newpath 114 600 moveto 631 600 lineto 464 200 lineto 573 200 lineto
   573 0 lineto -94 0 lineto 31 300 lineto -10 300 lineto closepath clip
   50 setlinewidth newpath 656 300 moveto 381 300 275 0 360 arc stroke
   -19 350 moveto 600 0 rlineto -19 250 moveto 600 0 rlineto stroke}d
 end
 /BuildChar{0 begin
  /char E D /fontdict E D /charname fontdict /Encoding get char get D
  fontdict begin
   Metrics charname get 0 BBox charname get aload pop setcachedevice
   CharacterDefs charname get exec
  end
 end}D
 /BuildChar load 0 3 dict put /UniqueID 1 D
end
definefont pop

/Cd {aload length 2 idiv dup dict begin {D} repeat currentdict end} D
/EX {EC cvx exec} D
/DU {} d
/BB {pop pop}d
/ie {ifelse} d
/E {exch} d
/M {moveto} d
/R {rmoveto} d
/L {lineto} d
/RL {rlineto} d
/CP {currentpoint} d
/SW {stringwidth} d
/GI {getinterval} d
/PI {putinterval} d
/Sg {setgray} d
/LW {setlinewidth} d
/S {dup () ne OU and{0 Co R AT 3 eq LB and HF not and A1 0 ne A2 0 ne or and
 {A2 0 32 A1 0 6 -1 roll awidthshow}{show}ie 0 Co neg R}{pop}ie
 OU PH 3 eq or{/Ms t D}if} D
/U {OU{gsave CP currentfont /FontInfo get /UnderlinePosition get
 0 E currentfont /FontMatrix get dtransform E pop add newpath M dup SW pop
 CJ 0 RL stroke grestore}if} D
/B {OU Br 0 gt and{CP Ts neg Ts .33 mul R gsave 0 Sg
 CP newpath Ts Br mul 0 360 arc closepath UI 2 mod 0 eq{stroke}{fill}ie
 grestore M CP E Ts Br 1 add mul sub E BB /Ms t D}if}D
/NP {Ms TP not or PA and OU and{TP{OR}if f1{mF k2 /mF E D /YC 0 D}if
 TP TU not PM 0 eq or and{showpage}if DU Ip TE not{LA}if 0.6 LW
 /CI 0 D /TP t D /Hs f D /hl 6 D /Hv 6 D /HI hi D /Ms f D}if Bs XO BO M} D
/Np {LE sub CP E pop gt PL 0 eq and{NP}if}D
/Ip {/PN PN 1 add D /Pn RM{1}{4}ie PN Ns D /PM PN SN sub 2 mod D} D
/GP {E dup 3 -1 roll get PN 1 add 2 mod get dup type /integertype eq
 {get 0 get}{E pop}ie}d
/Fc {dup 2 GP exec SW pop /S1 E D dup 1 GP exec SW pop /S2 E D 0 GP exec SW
 pop /S3 E D S1 0 gt{S2 2 mul S1 add S3 2 mul S1 add 2 copy lt{E}if pop}{0}ie
 S2 S3 add 2 copy lt{E}if pop IW .9 mul div dup 1 gt{1 E div}{pop 1}ie}D
/OR {Df{Sd}if tp not{gsave SA{1 Sf div dup scale}if Fe{Cf{FU VC}if FW LW
 1 setlinejoin FE stroke}if /YO {60 F div dup 40 gt{pop 40}if}D /cs CS D
 /cf CF D /CF 0 D /pf PF D /PF f D /Fn FN D /At AT D /AT 0 D /FN EF Hf 1 add
 get D Fz Fs FS ZZ Fc Fz mul Fs FS EU Hf 1 add get dup type /arraytype eq
 Cf and{VC}{pop 0 Sg}ie IW IL neg YO sub M ZZ 1 GP exec dup SW pop neg 0 R Sh
 0 IL neg YO sub M ZZ 0 GP exec Sh ZZ 2 GP exec dup SW pop IW E sub 2 div
 IL neg YO sub M Sh Fz Fs FS NO{/AW IW Pn SW pop sub D AW 2 div IL neg YO sub
 S1 0 gt S2 AW .45 mul gt or S3 AW .45 mul gt or{Fz 2 mul sub}if M Pn Sh}if
 EU Hf get dup type /arraytype eq Cf and{VC}{pop 0 Sg}ie YY Fc /FN EF Hf get D
 Hz mul HS FS IW YO M YY 1 GP exec dup SW pop neg 0 R Sh 0 YO M YY 0 GP exec Sh
 YY 2 GP exec dup SW pop IW E sub 2 div YO M Sh /FN Fn D /AT At D t Pb XO SZ
 SL get neg R /PF pf D grestore /CF 0 D cs cf FS}if}D
/Sh {dup () ne{CP Hz 4 div sub BB show CP CS add BB}{pop}ie}D
/Pb {/OU E D /Ou OU D /PB t D 0 0 M Ba{/Sa save D /BP t D /Fl t D RC /PL 0 D
 /PH 0 D /W IW D /LE IL .7 mul D /EO 0 D SI ZF /YA 0 D /BO 0 D /C1 () D
 BA 0 Ts neg R Bb{Xl Yl Xh Yh}if Bb CP Sa restore M
 {/Yh E D /Xh E D /Yl E D /Xl E D}if /Fl t D}if
 BL /OU t D /HM f D /Ou t D /PB f D} D
/Bs {/BP Ba not D}D
/reencodeISO {
 dup dup findfont dup length dict begin{1 index /FID ne{D}{pop pop}ie}forall
 /Encoding ISOLatin1Encoding D currentdict end definefont} D
/ISOLatin1Encoding [
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash
/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/space/exclamdown/cent/sterling/currency/yen/brokenbar
/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
/yacute/thorn/ydieresis
] D
[128/backslash 129/parenleft 130/parenright 141/circumflex 142/tilde
143/perthousand 144/dagger 145/daggerdbl 146/Ydieresis 147/scaron 148/Scaron
149/oe 150/OE 151/guilsinglleft 152/guilsinglright 153/quotesinglbase
154/quotedblbase 155/quotedblleft 156/quotedblright 157/endash 158/emdash
159/trademark]
aload length 2 idiv 1 1 3 -1 roll{pop ISOLatin1Encoding 3 1 roll put}for
/colorimage where{pop}{
 /colorimage {
  pop pop /Pr E D {/Cv Pr D /Gr Cv length 3 idiv string D 0 1 Gr length 1 sub
   {Gr E dup /i E 3 mul D Cv i get 0.299 mul Cv i 1 add get 0.587 mul add
    Cv i 2 add get 0.114 mul add cvi put}for Gr} image} D
}ie
/pdfmark where{pop}{userdict /pdfmark /cleartomark load put}ie
WF{FL{reencodeISO D}forall}{4 1 FL length 1 sub{FL E get reencodeISO D}for}ie
/Symbol dup dup findfont dup length dict begin
 {1 index /FID ne{D}{pop pop}ie}forall /Encoding [Encoding aload pop]
 dup 128 /therefore put D currentdict end definefont D

/SF {/CS E D SZ SL CS put FO SL FN put /YI CS LH neg mul D dup ST cvs ( ) join
 CS ST cvs join C1 E join ( NF ) join /C1 E D CS NF /Wf WF FN 0 gt or D
 /BW Wf{( ) SW pop}{0}ie D}D
/NF {/cS E D /cF E D cF 0 ge{FL cF get}{cF -1 eq{/Symbol}{/MySymbol}ie}ie
 findfont cS scalefont setfont} D
/FS {CF or /CF E D FR SL CF put CF CF 0 ge{FN 4 mul add}if E SF} D
/PC {SH /BP f D fin not GL not and{NL}if /HM t D /LL LS D} D
/BS {/TX E D Wf{/fin f D /CW 0 D /LK 0 D /SC 0 D
 /RT TX D {RT ( ) search{/NW E D pop /RT E D /WH NW SW pop D CW WH add LL gt
 {TX SC LK SC sub 1 sub NN GI GL{SH cF cS OC
 2 copy cS ne E cF ne or{NF}{pop pop}ie}{PC /CW WH BW add D}ie
 /SC LK D}
 {GL{JC}if
 /CW CW WH add BW add D /HM t D}ie /GL f D /Ph f D
 /LK LK NW length 1 add add D}{pop exit}ie}loop
 /fin t D TX SC LK SC sub GI SH RT () ne{GL not{CC}if}if
 /LC TX length D /WH RT SW pop D CW WH add Hy{HC SW pop add}if LL gt
 {RT GL{SH cF cS OC 2 copy cS ne E cF ne or{NF}{pop pop}ie
 Hy{/Ph t D}if /LL LS D}{NL /LL LS D SH}ie}
 {RT PC Hy{CC}if /Ph Ph Hy or D}ie RT () ne{/GL t D /HM t D}if}
 {TX SW pop LL le{TX SH}{/NW () D 0 2 TX length 1 sub
 {/CW E D TX 0 CW GI dup SW pop LL gt{pop NW SH /HM t D NL/LL W XO sub MR sub D
 /CW CW 2 sub NN D /TX TX CW TX length CW sub GI D TX BS exit}
 {/NW E D}ie}for}ie}ie /HM t D}D
/CC {C0 length 0 gt{JC}if /C0 [C1 L1 YA YB Mf NS NB TB AF Bw] D
 /C1 () D /L0 L1 D /YA 0 D /YB 0 D /Mf 0 D /NS 0 D /NB 0 D}D
/JC {C0 aload length 0 gt{pop pop pop NB add /NB E D NS add /NS E D
 dup Mf gt{/Mf E D}{pop}ie dup YB gt{/YB E D}{pop}ie
 dup YA gt{/YA E D}{pop}ie pop C1 join /C1 E D /C0 [] D}if}D
/OC {C0 length 0 gt{C1 L1 L0 sub YA YB Mf NS NB TB AF Bw GL C0 aload pop
 /Bw E D /AF E D /TB E D /NB E D /NS E D /Mf E D /YB E D /YA E D /C0 [] D
 /L1 E D /C1 E D Ph{HC SH}if NL /GL E D /Bw E D /AF E D /TB E D /NB E D /NS E D
 /Mf E D /YB E D /YA E D /L1 E D /LL W L1 sub XO sub MR sub WH sub D /CW 0 D
 C1 E join /C1 E D}if}D
/BT {/LB t D dup length string copy RS dup dup () ne E ( ) ne and
 {/CI 0 D /LS LL D /LL W L1 sub XO sub MR sub D BS}
 {dup ( ) eq{/GL f D}if dup () eq L1 0 eq or{pop}{SH /BP f D /Ph f D}ie}ie
 /LB f D} D
/BL {CP E pop XO E M} D
/NL {JC /GL f D /SK W XO sub MR sub L1 sub TB{Bw add}if D
 /YA LF{Mf HM Fl not and PF or{LH mul}if}{0 /LF t D}ie YA 2 copy lt{E}if pop D
 C1 () ne{/FB YB Mf SA{Sf mul}if 4 div 2 copy lt{E}if pop D}if Fl{/Ya YA D}if
 CP E pop YA sub YB sub LE neg lt Fl not and PB not and{NP}if NT TL BL
 OU PF not and PB or{/RE L1 TB{Bw sub}if
 W XO sub MR sub div YA YB add LE BO add div 2 copy lt{E}if pop D
 RE 1 gt{BL 1 RE div dup scale}if}if
 AT 2 le{SK AT mul 2 div YA neg R}if
 AT 3 eq{0 YA neg R TB{/NB NB 1 sub D /NS NS 1 sub D}if /NB NB 1 sub NN D
 /A3 NS 6 mul NB add D NS NB add 0 eq
  {/A1 0 D /A2 0 D}
  {NS 0 eq{/A1 SK NB div dup J gt{pop 0}if D /A2 0 D}{J A3 mul SK lt
   {/A1 J D /A2 SK J NB mul sub NS div dup Ab gt{/A1 0 D pop 0}if D}
   {/A1 SK A3 div D /A2 A1 6 mul D}ie}ie}ie /A1 A1 NN D /A2 A2 NN D}if
 AT 4 eq{0 YA neg R PH 2 le{PD 0 lt{/PD L1 D}if PD M1 gt{/M1 PD D}if
 L1 PD sub M2 gt{/M2 L1 PD sub D}if}{DV ID 1 sub get 0 ge{Lo 0 R}if}ie}if
 F0 cF ne Cs cS ne or{F0 Cs NF}if
 /ms Ms D /Ms f D CP FB sub
 C1 cvx exec XO EO sub L1 add TB{BW sub}if dup LM gt{/LM E D}{pop}ie
 PH 0 eq PH 4 eq or Ms and{HF not{/PO t D /AH t D}if
 BB CP YA add E AT 3 eq LB and{A1 sub}if TB{BW sub}if E BB}
 {pop pop}ie Ms HM PH 3 eq and or{/BP f D /Fl f D}if
 /Lo 0 D /L1 0 D /F0 cF D /Cs cS D BP not{0 YB NN neg R}if
 OU f1 and mF not and{k2 /f1 f D}if
 OU PF not and PB or{RE 1 gt{RE dup scale}if}if /Ms ms Ms or D
 /C1 AF{(Cp )}{()}ie D /YA 0 D /YB 0 D BL
 AT 4 eq LB not and PH 3 ge and
 {ID DV length lt{DV ID get dup 0 ge{DO E sub /Lo E D /L1 Lo D}{pop}ie
 /ID ID 1 add D}if}if /T t D CD{/LN LN 1 add D PD}if
 /PD -1 D /NS 0 D /NB 0 D /TB f D /Ph f D /Mf 0 D /HM f D} D
/RS {/TM E D /CN 0 D TM{10 eq{TM CN ( ) PI}if /CN CN 1 add D}forall
 /CN 0 D /BK HM EN and{0}{1}ie D TM
 {dup 32 ne{TM CN 3 2 roll put /CN CN 1 add D /BK 0 D}
 {pop BK 0 eq{TM CN 32 put /CN CN 1 add D}if /BK 1 D}ie}forall
 TM 0 CN GI dup dup () ne E ( ) ne and
 {dup CN 1 sub get 32 eq{/EN f D}{/EN t D}ie}if} D
/join {2 copy length E length add string dup 4 2 roll 2 index 0 3 index
 PI E length E PI}d
/WR {(\n) search{dup () ne BP not or
 {Li 4 le CP E pop YI Li mul add LE add 0 lt and PL 0 eq and{NP}if
 SH NL pop /Li Li 1 sub D WR}{pop pop WR}ie}{SH}ie /CI 0 D /BP f D} D
/SH {dup dup () ne E ( ) ne and PF or CS Mf gt and{/Mf CS D}if
 T not Wf and{( ) E join /T t D}if dup BP{/MF CS D}if
 AT 3 eq{2 copy length dup 0 gt{/NB E NB add D
 {( ) search{/NS NS 1 add D pop pop}{pop exit}ie}loop}{pop pop}ie}if
 CD PD 0 lt and{dup DC search{SW pop /PD E L1 add D pop pop}{pop}ie}if
 0 Np dup SW pop L1 add /L1 E D dup () ne
 {C1 (\() join E join (\)) join AU AF and UF or Wf and{( U ) join}if
 sF{( s ) join}if ( S ) join
 /C1 E D dup length 1 sub get 32 eq /TB E D /Bw BW D}{pop pop}ie} D
/BG {AI LG BC add add 0 eq} D
/ON {OU{Ty AR AI NN get dup 1 add Ln Ns Ty 2 mod 0 eq{(.  )}{(\)  )}ie join
 dup SW pop neg 0 R CP E 0 lt{0 E M}{pop}ie CP BB show /Ms t D}if} D
/Ln {AR AI 3 -1 roll put}D
/SP {dup CI lt BP not and{dup CI sub 0 E R /CI E D}{pop}ie} D
/BN {PF{WR /HM f D}{BT NL}ie} D
/NN {dup 0 lt{pop 0}if} D
/h {(h) HI ST cvs join cvx exec dup 1 get E Nf{0 get E join}{pop}ie} D
/H {/fn FN D /Hi E 1 add D 1 sub /HL E D /H2 HL 2 add D /GS EZ H2 get D
 E Tm H2 get GS mul BE dup 0 gt{1 sub}{pop EG H2 get dup 0 lt{pop AT}if}ie NA
 WW Np /SL SL 1 add D /FN EF H2 get D GS Ey H2 get FS
 EU H2 get Sc Hs not HL Hl lt and Hs HL hl lt and or Hi 0 eq or
 {/HI Hi D /Hs t D /hl HL D /Hv HL D}if HL Hl lt{/hi Hi D}if
 Nf HI 0 gt and{(h) Hi ST cvs join cvx exec 0 get WB}if
 /HF t D /AH f D /PO f D} D
/EH {Bm H2 get GS mul BE OA /SL SL 1 sub NN D /CF 0 D /FN fn D
 SZ SL get FR SL get FS /HF f D /GS Ts D ()Ec} D
/P {E PF{WR}{PO{EP}{BN}ie Ts 4 mul Np AE not{Tm 0 get Ts mul neg SP}if
 dup 0 ge AH and{Pi Pd}if}ie 1 sub dup 0 lt{pop AV AL get}if /AT E D /PO t D} D
/EP {PF{WR}{BN Ts 4 mul Np}ie AE not{Bm 0 get Ts mul neg SP}if
 /AT AV AL get D /PO f D} D
/BE {E PO{EP}{BN}ie Ts 4 mul Np neg SP} D
/HR {/Aw W EO sub D /RW E dup 0 gt{Aw mul}{neg}ie dup Aw gt{pop Aw}if D /RZ E D
 E BN Ts neg SP 1 sub 2 div Aw RW sub mul EO add CP E pop M PF{0 Ps neg R}if
 0 Np OU{gsave RZ LW Cf{Hc VC}{0 Sg}ie CP BB RW 0 RL CP BB stroke grestore}if
 /CI 0 D /BP f D PF not{Ts neg SP}if /Ms t D} D
/AD {I NL EG 14 get dup 0 lt{pop AT}if NA /AE t D Tm 14 get Ts mul neg SP
 Cf{EU 14 get dup -1 eq{pop CA CL get}if Sc}if} D
/DA {BN ()ES OA /AE f D ()Ec Bm 14 get Ts mul neg SP} D
/PR {/MW E D /Li E D Tm 1 get Ps mul BE 0 NA /FN Fp D /PF t D SI /SL SL 1 add D
 /CF 0 D Ps CS mul Ts div MW WC mul CS mul Ts div dup LL gt PL 0 eq and
 {LL div div}{pop}ie Ey 1 get FS CP E pop LE add YI neg div cvi dup Li lt
 AH and{4 lt YI Li mul 5 mul LE add 0 gt or PL 0 eq and{NP}if}{pop}ie
 EU 1 get Sc /GS Ps D}D
/RP {WR NL () /PF f D SI /FN 0 D ES Bm 1 get Ps mul neg SP OA /GS Ts D} D
/SI {/XO Lm 15 get BC NN mul Lm 16 get AI UI sub NN mul add
 Lm 17 get UI NN mul add Lm 20 get LG NN mul add Ts mul
 PF{Lm 1 get Ps mul add}if EO add D
 /MR Rm 15 get BC NN mul Rm 16 get AI UI sub NN mul add
 Rm 17 get UI NN mul add Rm 20 get LG NN mul add Ts mul
 PF{Rm 1 get Ps mul add}if D /LL W XO sub MR sub D} D
/DT {/cC E D BN /LG LG 1 sub D SI /LG LG 1 add D WW 2 div Np BL} D
/DD {WB Cc 0 eq cC 0 eq and L1 0 eq or Lm 20 get Ts mul L1 sub TB{BW add}if
 Ts 2 div lt or NL /LF E D SI BL /cC 0 D} D
/DL {Dc LG Cc put /Cc E D BG{Tm 18 get Ts mul BE}{BN}ie /LG LG 1 add D BL} D
/LD {BN LG 0 gt{/LG LG 1 sub D}if /Cc Dc LG get D SI
 BG{()Bm 18 get Ts mul BE}if BL} D
/UL {BG{Tm 17 get Ts mul BE}{BN}ie NR AI NN 0 put /UI UI 1 add D
 /AI AI 1 add D SI BL} D
/LU {BN /UI UI 1 sub D /AI AI 1 sub D SI BG{()Bm 17 get Ts mul BE}if BL} D
/OL {E BG{Tm 16 get Ts mul BE}{BN}ie TR AI NN Ty put /Ty E D NR AI NN 1 put
 /AI AI 1 add D SI BL 1 Ln} D
/LO {BN /AI AI 1 sub D /Ty TR AI get D SI BG{()Bm 16 get Ts mul BE}if BL} D
/LI {E BN -1 SP /BP f D /CI 0 D 0 Np NR AI 1 sub NN get 1 eq
 {dup dup 0 gt E 4 le and{/Ty E D}{pop}ie
 /L1 L1 Ty AR AI NN get Ns SW pop XO sub dup 0 lt{pop 0}if add D ( ON )}
 {pop ( B )}ie C1 E join /C1 E D CS Mf gt{/Mf CS D}if BL} D
/BQ {Tm 15 get Ts mul BE /BC BC 1 add D SI BL} D
/QB {Bm 15 get Ts mul BE /BC BC 1 sub D SI BL} D
/Al {E EP 1 sub dup 0 lt{pop AV AL get}if NA} D
/Ea {EP OA} D
/WB {PF{WR}{BT}ie} D
/F1 {WB /FN 0 D CS 0 FS} D
/F2 {WB /FN WI D CS 0 FS} D
/HY {/Hy t D WB /Hy f D} D
/YH {WB} D
/A {/LT E D LT 1 eq{/RN E D}if /Lh E D WB /C1 C1 ( Cp ) join D
 Lc AF not and{Cl Sc}if /AF t D} D
/EA {Lc AF and{Ec}{WB}ie TL Pa AF and Lh 0 ne and
 {( \() Lh join (\)) join /AF f D WB}if /AF f D} D
/TL {C1 ( Tl ) apa /C1 E D} d
/apa {AF OU and Lh 0 ne LT 1 eq or and{LT 1 eq{RN ( /) E ST cvs join}
 {(\() Lh join (\)) join}ie E join join}{pop}ie} d
/Cp {/Xc CP /Yc E D D} D
/SS {Cf{dup 0 ge{EU E get dup -1 eq{pop CA CL get}if}{pop CA CL get}ie Sc}
 {pop}ie SZ SL get /SL SL 1 add D} D
/I {WB 8 SS 1 FS} D
/EM {WB 8 SS /CF CF 1 xor D 0 FS} D
/BD {WB 9 SS 2 FS} D
/TT {WB 10 SS /FN Fp D 0 FS} D
/KB {WB 11 SS /FN Fp D 2 FS} D
/CT {WB 12 SS 1 FS} D
/SM {WB 13 SS /FN Fp D 0 FS} D
/Q {/QL QL 1 add D QO QL 2 mod get La get join WB} D
/EQ {QC QL 2 mod get La get join WB /QL QL 1 sub D} D
/RO {WB -1 SS /CF 0 D 0 FS} D
/SY {WB -1 SS -1 FS} D
/MY {WB -1 SS -2 FS} D
/ES {WB /SL SL 1 sub NN D /CF 0 D /FN FO SL get D SZ SL get FR SL get FS ()Ec}D
/FZ {3 sub 1.2 E exp GS mul E WB TL /C1 C1 ( Cp ) join D /SL SL 1 add D 0 FS} D
/Ef {WB TL ()ES /C1 C1 ( Cp ) join D} D
/BZ {dup /Bf E D FZ}D
/Sc {dup -1 ne Cf and{/CL CL 1 add D dup 0 eq{pop [0 0 0]}if
 dup CA E CL E put VS ( VC ) join C1 E join /C1 E D}{pop}ie} D
/Ec {WB Cf{/CL CL 1 sub NN D CA CL get VS ( VC ) join C1 E join /C1 E D}if} D
/VS {dup type /arraytype eq{([) E {ST cvs join ( ) join}forall (]) join}if} D
/VC {{255 div}forall setrgbcolor} D
/Sl {dup type /integertype ne{Ds}if /La E D WB}d
/UN {WB /UF t D} D
/NU {WB /UF f D} D
/SE {WB /sF t D} D
/XE {WB /sF f D} D
/sM {/C1 C1 ( k1 ) join D}d
/eM {/C1 C1 ( k2 ) join D}d
/k1 {/YC CP E pop Ts add D /mF t D /f1 t D}d
/k2 {gsave 3 LW -9 CP E pop Ts 0.2 mul sub M -9 YC L stroke grestore /mF f D}d
/Ac {/AC E D WB}d
/Ca {eA{( \()join AC join(\) )join}if WB}d
/s {OU{gsave 0 CS .25 mul R dup SW pop CJ 0 RL stroke grestore}if}D
/CJ {AT 3 eq LB and{E dup dup length 1 sub A1 mul E
 {( ) search{pop pop E A2 add E}{pop exit}ie}loop 3 -1 roll add
 W CP pop sub 2 copy gt{E}if pop}if}D
/So {/Co E D} D
/SO {C1 Yo ST cvs join ( So ) join /C1 E D (j) SW pop 2 div Pd} D
/Se {E WB CS E div Pd}D
/Pd {dup type /stringtype eq{SW pop}if dup /L1 E L1 add D
 ST cvs ( 0 R ) join C1 E join /C1 E D} D
/Sp {0.35 CO} D
/Sb {-0.2 CO} D
/CO {OV Io Yo put /Yo E CS mul Yo add D /Io Io 1 add D -1.5 Io mul 3 add FZ SO
 CS Yo add dup YA gt{/YA E D}{pop}ie
 Yo neg dup YB gt{/YB E D}{pop}ie} D
/Es {ES /Io Io 1 sub NN D /Yo OV Io get D SO} D
/SB {/N2 0 D 0 1 NI{/N E D{IX N2 get 0 lt{/N2 N2 1 add D}{exit}ie}loop
 /K WS N get FC N get mul D /NY AY N2 get D /BV NY array D
 0 1 NY 1 sub{/TM K string D currentfile TM readhexstring pop pop BV E TM put}
 for BM N BV put /N2 N2 1 add D}for} D
/IC [{/MA E D /MB 0 D}{2 div /MA E D /MB MA D}{/MB E CS sub D /MA CS D}
 {pop /MA YS AB mul D /MB 1 AB sub YS mul D}{pop /MA 0 D /MB 0 D}] D
/IP {BV N get /N N 1 add D} D
/II {/K E D IX K get 0 lt{/EC E D}if /TY E D
 TY 4 eq{/Y E D /X E D}if TY 3 eq{/AB E D}if
 /XW AX K get D /YW AY K get D /IS SG IT K get get D /XS XW IS mul D
 /YS YW IS mul D YS IC TY get exec /MA MA Fl not{3 add}if D} D
/IM {II /ty TY D /xs XS D /ys YS D /ya YA D /yb YB D /ma MA D /mb MB D /k K D
 /ec EC D /BP f D /CI 0 D WB TL L1 xs add dup XO add MR add W gt
 {pop /ma ma Fl{3 add}if D NL /YA ma D /YB mb D /YS ys D /L1 xs D}
 {/L1 E D ma YA gt{/YA ma D}if mb YB gt{/YB mb D}if}ie /TB f D
 OU{CP E pop YS sub LE neg lt Fl not and PB not and{NP /YA ma D /YB mb D}if
 /BP f D ty ST cvs ( ) join IX k get 0 lt{(\() join ec join (\) ) join}if
 k ST cvs join ty 3 eq{AB ST cvs ( ) join E join}if
 ty 4 eq{X ST cvs ( ) join Y ST cvs join ( ) join E join}if C1 E join
 ( DI ) join FP 2 eq FP 1 eq AF and or{( FM ) join}if
 ( Il Cp ) apa /C1 E D /EN f D}if /HM t D /T f D} D
/DI {II /Xc CP /Yc E D D /YN YW neg D /HM t D /CI 0 D /K2 IX K get D gsave
 TY 4 eq{OX X IS mul add OY FY add YS sub Y IS mul sub}
 {/FY YS D CP MB sub 2 copy /OY E D /OX E D}ie
 translate K2 0 ge{/DP AZ K2 get D /BV BM K2 get D XS YS scale /N 0 D XW YW DP
 [XW 0 0 YN 0 YW] {IP} FC K2 get 1 eq{image}{f 3 colorimage}ie}
 {EX}ie grestore XS 0 R /Ms t D} D
/FM {gsave 0 Sg CP MB sub translate XS neg 0 M 0 YS RL XS 0 RL 0 YS neg RL
 XS neg 0 RL stroke grestore} D
/NA {/AT E D /AL AL 1 add D AV AL AT put} D
/OA {AL 0 gt{/AL AL 1 sub D /AT AV AL get D}if} D
/D1 {/BR {CP E pop E BN Mb{CP E pop eq{0 YI R}if}{pop}ie} D
 /Sn {OU{C1 E ST cvs join ( Ld ) join /C1 E D}{pop}ie} D} D
/D1 {/BR {BN} D /Sn {OU {C1 E ST cvs join ( Ld ) join /C1 E D} {pop} ie} D} D
/TC {/TF t D /ML 0 D HN{SW pop dup ML gt{/ML E D}{pop}ie}forall NP /RM RM not D
 RC /OU Tc D Ep /PN 0 D Ms not TP and{Ip}if /W IW ML sub Ts sub D
 /A0 0 D TH{/BR {( ) join BT} D /Sn {pop} D /Au () D}if} D
/TN {0 eq{E EA PF HF or not XR and{HN E get Xr}{pop}ie}
 {OU{Tn 0 ge{() BN}if /Tn E D}{pop}ie WB}ie} D
/NT {OU LB not and Tn 0 ge and{PL 0 eq{Ms not{CS CF FS}if CP dup
 /y E YA sub D W 9 sub CS -1.8 mul XO L1 add 2 add{y M (.) show}for
 HN Tn get dup SW pop IW E sub y M show CP BB M}if /Tn -1 D}if} D
/Ld {/DN E D HN DN Pn put [/View [/XYZ -4 Fl{PS}{CP YA add US E pop}ie null]
 /Dest DN ST cvs cvn /DEST pdfmark} D
/C {ND 1 eq{1 sub}if TI mul /XO E D NL Nf not{pop()}if 0 3 -1 roll 1 A} D
/OP {BP not{NP}if PN 2 mod 0 eq{NP}if}D
/Ep {Xp PN 2 mod 0 eq and OU and{/Pn (-) D showpage /PM 1 D LA}if}D
/Dg [73 86 88 76 67 68 77] D
/Rd [0 [1 1 0][2 1 0][3 1 0][2 1 1][1 1 1][2 2 1][3 3 1][4 4 1][2 1 2]] D
/Ns {/m E D /c E 32 mul D /j m 1000 idiv D /p j 12 add string D
 c 96 le m 0 gt and{c 32 le {/i 0 D /d 77 D /l 100 D /m m j 1000 mul sub D
  j -1 1 {pop p i d c add put /i i 1 add D}for
  4 -2 0 {/j E D /n m l idiv D /m m n l mul sub D /d Dg j get D
   n 0 gt {/x Rd n get D x 0 get -1 1 {pop p i d c add put /i i 1 add D}for
   p i x 1 get sub Dg x 2 get j add get c add put}if /l l 10 idiv D
  }for p 0 i GI}
  {/i ST length 1 sub D m {1 sub dup 0 ge{dup 26 mod c add 1 add
   ST i 3 -1 roll put 26 idiv dup 0 eq{pop exit}if}if /i i 1 sub D}loop
   ST i ST length i sub GI}ie}
 {m p cvs}ie} D
/US {matrix currentmatrix matrix defaultmatrix matrix invertmatrix
 matrix concatmatrix transform} D
/GB {Gb{US}if}D
/Tl {/Rn E D Xc CP pop ne{
 [/Rect [Xc 1 sub Yc cS 0.25 mul sub GB CP E 1 add E cS 0.85 mul add GB]
  /Subtype /Link /Border [0 0 Cf Lc and LX and AU or{0}{1}ie] Rn type
  /nametype eq {/Dest Rn}{/Action [/Subtype /URI /URI Rn] Cd}ie
  /ANN pdfmark}if} D
/Il {/Rn E D [/Rect [Xc Yc GB Xc XS add Yc YS add GB] /Subtype /Link
 /Border [0 0 0] Rn type /nametype eq{/Dest Rn}
 {/Action [/Subtype /URI /URI Rn] Cd}ie /ANN pdfmark} D
/XP {[{/Z Bz 2 div D Z 0 R Z Z RL Z neg Z RL Z neg Z neg RL Z Z neg RL
 Fi cH 1 eq and{fill}if} {Bz 0 RL 0 Bz RL Bz neg 0 RL 0 Bz neg RL
 Fi cH 1 eq and{fill}if} {0 -5 R Bz 0 RL 0 21 RL Bz neg 0 RL 0 -21 RL}]} D
/MS {/Sm E D WB}D
/O {BN()Sm BX} D
/BX {/Bt E D Bt 2 lt{/Ch E D CS 0.8 mul}{11 mul}ie W XO sub MR sub
 2 copy gt{E}if pop /HZ E D Bt 2 eq{Fi not{pop()}if ( )E join /Ft E D TT
 /PF t D /MW 1 D /Li 1 D /Fw Ft SW pop D Fw HZ gt{/HZ Fw 8 add D}if
 HZ ST cvs( )join}{WB Ch ST cvs( )join}ie L1 HZ add XO add MR add W gt{NL}if
 Bt 2 eq{Ft ES Fw neg HM{CS sub}if Pd}if Bt ST cvs join( Bx )join
 Bt 2 eq HM and{CS Pd}if C1 E join /C1 E D /L1 L1 HZ add D /T f D
 ( ) Pd /PF f D Bt 2 lt{YA CS .8 mul lt{/YA CS .8 mul D}if}
 {YB 5 lt{/YB 5 D}if YA 21 lt{/YA 21 D}if}ie /CI 0 D} D
/Bx {dup 2 eq{E /Bz E D}{E /cH E D /Bz CS .8 mul D}ie
 OU {gsave 0 Sg XP E get exec stroke grestore}{pop}ie Bz 0 R /Ms t D}D
/SD {FD 4 mul Dy add DZ NF newpath 0 0 M DX t charpath pathbbox
 3 -1 roll sub /DY E D E dup /X1 E D sub WM mul WX DY mul add WM DG mul E div
 /DF E D /DR WX DF mul DY mul WM div 2 div D} d
/Sd {gsave 0 IL Di mul neg translate IL IW atan Di 0 eq{neg}if rotate
 FD 4 mul Dy add DZ NF DR X1 sub DY 2 div neg M cD VC DX show grestore} d
/Pt {/tp t D Tp{NP /Pn (TP) D 0 Tt neg R Th BN NP Ep ET RC ZF}if /tp f D} D
/RC {/AI 0 D /LG 0 D /BC 0 D /UI 0 D /PF f D /Cc 0 D /cC 0 D /Dc 10 array D
 /NR [0 1 9{pop 0}for] D /La Ds D /AR 10 array D /TR 10 array D /AV 30 array D
 SI /AL -1 D /AT A0 D AT NA /OV 9 array D /Yo 0 D /Co 0 D /Io 0 D /Hy f D
 /Ph f D /CL -1 D Ct Sc}D
/ZF {/FR [0 1 30{pop 0}for] D /SZ [0 1 30{pop 0}for] D /FO [0 1 30{pop 0}for] D
 /SL 0 D /CF 0 D /FN 0 D 0 Ts SF}D
/QO [[(\253)(\232)(\234)(\253\240)(\233)(\273)][(\253)(\231)(')(\253\240)(`)(\273)]] D
/QC [[(\273)(\233)(\234)(\240\273)(\234)(\253)][(\273)(`)(')(\240\273)(')(\253)]] D
/Hf EF length 2 sub D
/Hz EZ Hf get D
/HS Ey Hf get D
/Fz EZ Hf 1 add get D
/Fs Ey Hf 1 add get D
/LE IL D
/Ps EZ 1 get D
/Fp EF 1 get D
/XO 0 D
/YI 0 D
/CI 0 D
/FP 0 D
/WW Ts 7 mul D
/Mf 0 D
/YA 0 D
/YB 0 D
/Cs Ts D
/GS Ts D
/F0 0 D
/NS 0 D
/NB 0 D
/N 0 D
/C0 [] D
/C1 () D
/Lo 0 D
/L1 0 D
/LM 0 D
/PH 0 D
/EC 0 D
/Lh 0 D
/LT 0 D
/CH 1 string D
/ST 16 string D
/CA 9 array D
/HC (\255) D
/HM f D
/PF f D
/EN f D
/TB f D
/UF f D
/sF f D
/AE f D
/AF f D
/BP t D
/CD f D
/PA t D
/GL f D
/T t D
/HF f D
/AH f D
/SA f D
/PB f D
/f1 f D
/mF f D
/OX 0 D
/OY 0 D
/FY 0 D
/EO 0 D
/FB 0 D
/PL 0 D
/Bw 0 D
/PD -1 D
/TP f D
/tp f D
/TH t D
/Ty 4 D
/Tn -1 D
/Fl t D
/LB t D
/PM 1 D
/Ms f D
/Ba f D
/Bb f D
/Hl 3 D
/hl 6 D
/Hv 6 D
/Hs f D
/HI 0 D
/hi 0 D
/PO t D
/TE f D
/LF t D
/BO 0 D
/Sm 1 D
/Bf 3 D
/A1 0 D
/A2 0 D
/Ds 4 D
/QL -1 D
/Cb Db D
/Ct Dt D
/Cl Dl D
[/Creator (html2ps version 1.0 beta3) /Author () /Keywords () /Subject ()
 /Title (class XmlConfig) /DOCINFO pdfmark
/ND 1 D
/HN [1 1 71{pop (??)}for] D
/h0 [()(Table of Contents)] D
/h1 [(0.0.0.1\240\240)(Public Methods)] D
/h2 [(0.0.0.2\240\240)(Private Methods)] D
/h3 [(0.0.0.3\240\240)(Private Members)] D
/h4 [(0.1\240\240)(Detailed Description)] D
/Hr [-67 -67 -67 67 68 69 70]D
/HV [1 2 3 4 4 4 2]D
/Cn [2 1 3 0 0 0 0]D
Hr length 0 gt{[/PageMode /UseOutlines /DOCVIEW pdfmark}if
/Hn 1 D
0 1 Hr length 1 sub{
 /Bn E D [Cn Bn get dup 0 gt{/Count E HV Bn get Bl ge{neg}if}{pop}ie
 /Dest Hr Bn get dup abs ST cvs cvn E 0 ge{(h)Hn ST cvs join cvx exec
 dup 1 get E Nf{0 get E join}{pop}ie /Hn Hn 1 add D}{()}ie
 /Title E dup length 255 gt{0 255 getinterval}if /OUT pdfmark}for
ZF /FN Fp D Ps 0 FS /WC Wf{( )}{<A1A1>}ie SW pop D
ET RC ZF
/Df f D
/TS {
 tables E get /table E D
 table aload pop /rdesc E D /cdesc E D /tdesc E D
 tdesc aload pop /capalg E D /caption E D /rules E D /frame E D /nfoot E D
  /nhead E D /ncol E D /nrow E D /border E D /twid E D /units E D /talign E D
  /flow E D /clear E D /tclass E D pop pop
 /w W D /eps 0.1 D /OU f D /PL 1 D
 /FN EF 21 get D EZ 21 get Ey 21 get FS
 0 1 1{
  /pass E D
  0 1 nrow{
   /irow E D
   /cells rdesc irow get 6 get D
   0 1 ncol{
    /icol E D
    /cell cells icol get D
    cell 0 ne{
     cell aload pop /ang E D /CB E D pop pop pop
     /DV E D /bot E D /top E D /right E D /left E D /nowrap E D /valign E D
     /dp E D /align E D /rspan E D /cspan E D /cclass E D /ctype E D /cmax E D
     /cmin E D /proc E D
     rspan 0 eq{/rspan nrow irow sub 1 add D}if
     cspan 0 eq{/cspan ncol icol sub 1 add D}if
     pass 0 eq cspan 1 eq and pass 1 eq cspan 1 gt and or{
      /W 1e5 D /LL W D /PH 1 D
      ctype 1 eq{() BD}if
      RC align NA
      AT 4 eq{/CD t D /DC dp D /LN 0 D /M1 0 D /M2 0 D}{/CD f D}ie
      0 0 M /LM 0 D proc exec BN
      AT 4 eq{
       LN array astore cell 15 3 -1 roll put
       cdesc icol get dup dup 5 get M1 lt{5 M1 put}{5 get /M1 E D}ie
       dup 6 get M2 lt{6 M2 put}{6 get /M2 E D}ie
       /LM M1 M2 add D
      }if
      /CD f D
      ang 0 ne{/LM CP E pop neg D}if
      /thiswid LM left add right add eps add D
      /oldmin 0 D /oldmax 0 D
      0 1 cspan 1 sub{
       icol add cdesc E get dup 2 get /oldmax E oldmax add D
       1 get /oldmin E oldmin add D
      }for
      thiswid oldmax ge{
       0 1 cspan 1 sub{
        icol add cdesc E get dup 2 E 2 get oldmax 0 eq
         {pop thiswid cspan div}{thiswid mul oldmax div}ie
        put
       }for
      }if
      nowrap 1 eq{
       thiswid oldmin ge{
        0 1 cspan 1 sub{
         icol add cdesc E get dup 1 E 1 get oldmin 0 eq
          {pop thiswid cspan div}{thiswid mul oldmin div}ie
         put
        }for
       }if
      }{
       /W 0 D /LL W D /PH 2 D
       ctype 1 eq{() ES () BD}if
       0 0 M /LM 0 D RC proc exec BN
       /thiswid LM left add right add eps add D
       thiswid oldmin ge{
        0 1 cspan 1 sub{
         icol add cdesc E get dup 1 E 1 get oldmin 0 eq
          {pop thiswid cspan div}{thiswid mul oldmin div}ie
         put
        }for
       }if
      }ie
      ctype 1 eq{() ES}if
     }if
    }if
   }for
  }for
 }for
 /tmin 0 D /tmax 0 D
 0 1 ncol{
  cdesc E get dup 1 get E 2 get 2 copy gt{pop dup}if
  tmax add /tmax E D tmin add /tmin E D
 }for
 twid 0 lt{twid neg IW gt{IW neg}{twid}ie /twid E D}if
 tdesc 0 twid neg tmin 2 copy lt{E}if pop put
 tdesc 1 twid neg tmax 2 copy lt{E}if pop put
 /W w D /LL W D /OU t D /PH 0 D /PL 0 D
} D
/PT {
 /PL PL 1 add D
 tables E get /table E D Tm 21 get Ts mul BE
 PL 2 ge{save}if
 /SL SL 1 add D /FN EF 21 get D EZ 21 get Ey 21 get FS
 table aload pop /rdesc E D /cdesc E D /tdesc E D
 tdesc aload pop /capalg E D /caption E D /rules E D /frame E D /nfoot E D
  /nhead E D /ncol E D /nrow E D /border E D /twid E D /units E D /talign E D
  /flow E D /clear E D /tclass E D /tmax E D /tmin E D
 /w W D /xo XO D /mr MR D /ll LL D /lg LG D /ai AI D /bc BC D /nr NR D /ar AR D
 /tr TR D /ui UI D /ph PH D /a0 A0 D /pf PF D /at AT D /av AV D /al AL D
 /Le LE D /la La D
 talign 0 lt{/talign AL 0 gt{AV AL get}{A0 2 le{A0}{0}ie}ie D}if
 ph 1 eq ph 2 eq or{
  NL ph 1 eq{tmax}{tmin}ie dup XO add LM gt{/LM E XO add D}{pop}ie LM E
 }{
  /PH 3 D /LE 1e5 D RC %ZF
  border 0 gt{/border 1 D}if
  /twidth 0 D /avail W xo sub D
  twid 0 eq{0 1 ncol{cdesc E get dup 2 get E 3 get dup 0 gt{div neg dup twid lt
   {/twid E D}{pop}ie}{pop pop}ie}for}if
  /twid twid dup 0 lt{neg avail 2 copy gt{E}if pop}{avail mul}ie D
  /OK t D 0 1 ncol{cdesc E get dup 1 get E 3 get twid mul gt{/OK f D}if}for
  0 1 ncol{
   cdesc E get dup 1 get /colmin E D dup 3 get /cwid E twid mul D dup
   tmax avail le{2 get}if
   tmin avail le tmax avail gt and{
    dup 2 get E 1 get dup 3 1 roll sub avail tmin sub mul tmax tmin sub div add
   }if
   tmin avail gt{1 get}if
   0 E colmin cwid lt OK and{pop cwid}if dup /twidth E twidth add D put
  }for
  /OU f D CP
  tmin twid le{
   0 1 ncol{cdesc E get dup 0 get twidth div twid mul 0 E put}for
   /twidth twid D
  }if
  CP printcap CP E pop sub /caphig E D pop
  0 1 1{
   /pass E D
   0 1 nrow{
    /irow E D
    /cells rdesc irow get 6 get D
    0 1 ncol{
     /icol E D
     /cell cells icol get D
     cell 0 ne{
      cell aload pop /ang E D /CB E D pop pop pop
      /DV E D /bot E D /top E D /right E D /left E D /nowrap E D /valign E D
      /dp E D /align E D /rspan E D /cspan E D /cclass E D /ctype E D /cmax E D
      /cmin E D /proc E D
      rspan 0 eq{/rspan nrow irow sub 1 add D}if
      cspan 0 eq{/cspan ncol icol sub 1 add D}if
      /W 0 D
      0 1 cspan 1 sub{icol add cdesc E get 0 get /W E W add D}for
      pass 0 eq rspan 1 eq and pass 1 eq rspan 1 gt and or{
       ctype 1 eq{() BD}if
       /W W left sub right sub D /XO 0 D /EO 0 D SI
       /A0 align D RC align NA
       AT 4 eq{
        /DC dp D /DO 0 D /ID 1 D
        0 1 DV length 1 sub{DV E get dup DO gt{/DO E D}{pop}ie}for
        /Lo DO DV 0 get sub D /L1 Lo D
       }if
       0 0 M /BP t D /Fl t D /MF 0 D /FB 0 D
       proc exec T not{/CI 0 D}if BN 0 FB neg R MF 0 eq{/MF CS D}if
       CP /thishig E neg bot add top add CI add D pop
       ang 0 ne{/thishig LM bot add top add D}if
       cell 16 MF put cell 17 Ya put cell 18 thishig put
       valign 4 eq{
        /below thishig Ya sub D
        rdesc irow get dup dup 4 get Ya lt
         {4 Ya put}{4 get /Ya E D}ie
        dup 5 get below lt{5 below put}{5 get /below E D}ie
        /thishig Ya below add D
       }if
       ctype 1 eq{()ES}if
       /oldhig 0 D
       0 1 rspan 1 sub{
        irow add rdesc E get 0 get /oldhig E oldhig add D
       }for
       thishig oldhig ge{
        0 1 rspan 1 sub{
         irow add rdesc E get dup 0 E 0 get oldhig 0 eq
          {pop thishig rspan div}{thishig mul oldhig div}ie
         put
        }for
       }if
      }if
     }if
    }for
   }for
  }for M RC %ZF
  /thight 0 D /racc 0 D /maxh 0 D /brk 0 D /rbeg nhead nfoot add D
  rbeg 1 nrow{
   rdesc E get dup 0 get dup /thight E thight add D
   brk 0 eq{/racc E D}{/racc E racc add D}ie
   racc maxh gt{/maxh racc D}if 2 get /brk E D
  }for
  ph 3 ge{thight caphig add E}if
  ph 0 eq ph 4 eq or{
   /PH 4 D /LE Le D /OU Ou D /yoff 0 D /headsz 0 D
   0 1 nhead 1 sub{rdesc E get 0 get headsz add /headsz E D}for
   /footsz 0 D
   0 1 nfoot 1 sub{rdesc E nhead add get 0 get footsz add /footsz E D}for
   /ahig LE BO add MI add D /maxh maxh headsz add footsz add D
   /thight thight headsz add footsz add D
   tmin avail gt maxh ahig gt or
    {/Sf avail tmin div dup ahig maxh div gt{pop ahig maxh div}if D /SA t D}
    {/Sf 1 D}ie
   tclass 1 eq thight LE 15 sub gt and
    {/SA t D LE 15 sub thight div dup Sf lt{/Sf E D}{pop}ie}if
   SA{Sf Sf scale /ll ll Sf div D /xo xo Sf div D /LE LE Sf div D
    /mr mr Sf div D /BO BO Sf div D /ahig ahig Sf div D}if
   nhead nfoot add getwid
   LE CP E pop add capalg 0 eq{caphig sub}if
   bT{f}{dup thight lt thight ahig lt and}ie
   E headsz sub footsz sub rwid lt or{NP}if
   capalg 0 eq{printcap -8 SP}if
   CP /ycur E D pop
   printhead
   rbeg 1 nrow{/row E D row
    getwid
    ycur yoff add rwid sub footsz sub LE add 0 lt
    {nfoot 0 gt{printfoot}if Tf NP /rbeg irow1 D
     Ba{MI /MI MI SA{Sf div}if D MI SP /MI E D}if
     CP /ycur E D pop /yoff 0 D printhead}if
    irow1 printrow
   }for
   printfoot /row row 1 add D Tf
   0 ycur yoff add M
   capalg 1 eq{/EO 0 D SI -3 SP printcap}if
   Sf 1 lt{1 Sf div dup scale /ll ll Sf mul D /xo xo Sf mul D /LE LE Sf mul D
    /mr mr Sf mul D /BO BO Sf mul D /SA f D}if
   /EO 0 D
  }if
 }ie
 /W w D /XO xo D /MR mr D /LL ll D /LG lg D /AI ai D /BC bc D /NR nr D /AR ar D
 /TR tr D /UI ui D /PH ph D /A0 a0 D /PF pf D /AT at D /AV av D /AL al D
 /La la D
 /SL SL 1 sub NN D /CF 0 D /FN 0 D SZ SL get FR SL get FS Wf not{()F2}if
 PL 2 ge{Ms E restore Ms or /Ms E D PH 1 eq PH 2 eq or
  {/LM E D}if PH 3 ge{/CI 0 D NL 0 E neg R}if
 }if
 /PL PL 1 sub D /CI 0 D /BP f D /PO f D () Bm 21 get Ts mul BE BL %CF CS SF
} D
/printcap{
 capalg 0 ge{
  SA{/W w Sf div D}
   {talign 1 eq{/XO xo ll twidth sub 2 div add D}if
    talign 2 eq{/XO xo ll twidth sub add D}if
    /W XO twidth add D
   }ie /XO xo D /LL W XO sub MR sub D
  /PA f D /Fl capalg 0 eq D
  1 NA BL caption exec BN OA /PA t D
 }if
} D
/getwid{
 /irow1 E D
 /irow2 irow1 D
 /rwid 0 D
 {rdesc irow2 get dup 0 get rwid add /rwid E D 2 get 0 eq
  {exit}{/irow2 irow2 1 add D}ie
 }loop
} D
/printrow{
 /xoff ll twidth PL 2 ge{Sf div}if sub talign mul 2 div D
 /xleft xoff xo add D
 /irow E D
 /cells rdesc irow get 6 get D
 0 1 ncol{
  /icol E D
  /cell cells icol get D
  cell 0 ne{
   cell aload pop /ang E D /CB E D /cvsize E D /above E D /fontsz E D
   /DV E D /bot E D /top E D /right E D /left E D /nowrap E D /valign E D
   /dp E D /align E D /rspan E D /cspan E D /cclass E D /ctype E D /cmax E D
   /cmin E D /proc E D
   rspan 0 eq{/rspan nrow irow sub 1 add D}if
   cspan 0 eq{/cspan ncol icol sub 1 add D}if
   /width 0 D
   0 1 cspan 1 sub{icol add cdesc E get 0 get /width E width add D}for
   /rhight rdesc irow get 0 get D
   /hight rhight D
   1 1 rspan 1 sub{irow add rdesc E get 0 get /hight E hight add D}for
   /W xo xoff add width add right sub D
   ang 0 ne{/W xo xoff add hight add right sub D}if
   /EO xo xoff add left add D SI
   Cf{
    gsave CB VC xo xoff add ycur yoff add M
    0 hight neg RL width 0 RL 0 hight RL width neg 0 RL fill
    grestore
   }if
   ctype 1 eq{() BD}if
   /A0 align D RC
   AT 4 eq{
    /DC dp D /ID 1 D /DO cdesc icol get 5 get D /Lo DO DV 0 get sub D /L1 Lo D
   }if
   ang 0 ne{
    gsave ang 90 eq
     {xoff ycur add hight cvsize sub 2 div sub ycur hight sub xoff sub}
     {xoff ycur sub width add hight cvsize sub 2 div add ycur xoff add}ie
    translate ang rotate
   }if
   valign 3 le{0 ycur yoff add top sub
    hight cvsize sub valign 1 sub mul 2 div sub M}
   {0 ycur yoff add top sub above add rdesc irow get 4 get sub M}ie
   /PA f D /BP t D /Fl t D
   BL proc exec BN
   ang 0 ne{grestore}if
   /PA t D
   ctype 1 eq{() ES}if
  }if
  /xoff xoff cdesc icol get 0 get add D
 }for
 /yoff yoff rhight sub D
} D
/printhead {0 1 nhead 1 sub{printrow}for} D
/printfoot {nhead 1 nhead nfoot add 1 sub{printrow}for} D
/Tf {
 OU{rules 2 ge{/yoff 0 D
   gsave 0 Sg
   [0 1 nhead 1 sub{}for rbeg 1 row 1 sub{}for nhead 1 nhead nfoot add 1 sub{}for]{
    /irow E D
    /xoff ll twidth PL 2 ge{Sf div}if sub talign mul 2 div D
    /cells rdesc irow get 6 get D
    0 1 ncol{
     /icol E D
     /cell cells icol get D
     cell 0 ne{
      /rspan cell 6 get D
      /cspan cell 5 get D
      rspan 0 eq{/rspan nrow irow sub 1 add D}if
      cspan 0 eq{/cspan ncol icol sub 1 add D}if
      /width 0 D
      0 1 cspan 1 sub{icol add cdesc E get 0 get /width E width add D}for
      /rhight rdesc irow get 0 get D
      /hight rhight D
      1 1 rspan 1 sub{irow add rdesc E get 0 get /hight E hight add D}for
      xo xoff add width add ycur yoff add M
      0 hight neg icol cspan add 1 sub ncol lt
       {cdesc icol 1 add get 4 get dup rules 3 le{1 eq}{pop t}ie
        {1 eq{0.8}{0.3}ie
        LW RL CP stroke M}{pop R}ie}{R}ie
      irow nhead nfoot add 1 sub ne nfoot 0 eq or
       {irow rspan add 1 sub nrow lt
       {rdesc irow rspan add get 3 get}{nfoot 0 eq{0}{1}ie}ie
       dup rules 2 mod 0 eq{1 eq}{pop t}ie
       {1 eq irow rspan add nhead eq or irow rspan add row eq nfoot 0 gt and or
        {0.8}{0.3}ie LW width neg 0 RL CP stroke M}{pop}ie}if
     }if
     /xoff xoff cdesc icol get 0 get add D
    }for
    /yoff yoff rhight sub D
   }forall
   grestore
   /Ms t D
  }if
  frame 1 gt{
   gsave
   1 LW 0 Sg
   xleft ycur M CP BB
   0 yoff frame 5 eq frame 7 ge or{RL}{R}ie
   twidth 0 frame 3 eq frame 4 eq or frame 8 ge or{RL}{R}ie CP BB
   0 yoff neg frame 6 ge{RL}{R}ie
   twidth neg 0 frame 2 eq frame 4 eq or frame 8 ge or{RL}{R}ie
   closepath stroke
   grestore
   /Ms t D
  }if
 }if
} D
/tables [[[0 0 0 0 0 -1 0 -0 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(  )0 1 -1 H(class XmlConfig)EH(
  )} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(this class give access to the xml files in a silly but easy way. )2 FZ()0 1 1 A(More...)1 0 TN TL()Ec /AF f D()ES()} 0 0 0 0 1 1 2 (.) 1 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(Definition)} 0 0 1 0 1 1 1 (.) 2 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB()SM(#include <)0 2 A(parted2xml/xmlconfig.h)EA(>)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(List of all Methods)EA()} 0 0 1 0 1 1 1 (.) 2 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()}0 0 0 0 1 1 0(.)0 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 4 0 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()2 FZ()0 2 A(Annotated List)EA()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()2 FZ()0 2 A(Files)EA()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()2 FZ()0 2 A(Globals)EA()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()2 FZ()0 2 A(Hierarchy)EA()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()2 FZ()0 2 A(Index)EA()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB( )0 PT(
 )2 1 1 HR( )1 PT(
 )} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB()2 PT()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(\240)BD(XmlConfig)ES( \201)0 2 A(QString)EA( file, int mode=IO_ReadOnly\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(XmlConfig)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(file)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(File we read the XML from , if the file can't be read or it's not a valid XML
 file will print an error messague and exit)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(mode)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(The mode we open the document. If we open the document in readonly mode we can't
 save the changes in the same file, so it's safe always to read from a XML without breaking it
 )} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(\240)BD(~XmlConfig)ES( \201\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(~XmlConfig)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(int \240)BD(howManyTags)ES( \201const )0 2 A(QString)EA( tag\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(howManyTags)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(tag)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(It's the tag we look for, we return the number of the tags with this name
 in the domain)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(domain)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(It's the domain we look the tags in. If domain is nullptr, we look in
 the entire document. Example     howManyTags \201"partition"\202  returns 3
 howManyTags\201"partition","disk[0]"\202 returns 2
 howManyTags\201"partition", "disk[1]"\202 returns 1)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(int \240)BD(howManyAtributes)ES( \201)0 2 A(QString)EA( tag\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(howManyAtributes)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(tag)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(in the form "x[n].y[m].z[p]")} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(bool \240)BD(save)ES( \201const )0 2 A(QString)EA( file=nullptr\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(save)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(file)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the file we want to save the XML data in)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QDomDocument)EA( \240)BD(cloneDocument)ES( \201\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(cloneDocument)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QString)EA( \240)BD(file)ES( \201\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(file)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QString)EA( \240)BD(readString)ES( \201const )0 2 A(QString)EA( tag\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(readString)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(tag)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(from where we are going to read data)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(int \240)BD(readInt)ES( \201const )0 2 A(QString)EA( key\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(readInt)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(bool \240)BD(write)ES( \201const )0 2 A(QString)EA( tag,const )0 2 A(QString)EA( value\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(write)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(tag)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the tag where we want to write the value)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(value)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the value to be written)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(bool \240)BD(write)ES( \201const )0 2 A(QString)EA( tag,const int value\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(write)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(tag)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the tag where we want to write the value)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(value)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the value to be written)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(bool \240)BD(doWrite)ES( \201const )0 2 A(QString)EA( tag, const )0 2 A(QString)EA( value\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(doWrite)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(tag)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the tag to be written)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(value)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the value to be written)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(bool \240)BD(doWrite)ES( \201const )0 2 A(QString)EA( tag, const int value\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(doWrite)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(tag)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the tag to be written)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(value)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the value to be written)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(bool \240)BD(createElement)ES( \201const )0 2 A(QString)EA( node_name, const )0 2 A(QString)EA( value=nullptr, const )0 2 A(QString)EA( comment=nullptr\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(createElement)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 2 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(node_name)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the name for this element)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(value)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the value, for convenience, it saves to call write afterwards)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(comment)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the comment that will be written JUST BEFORE, half implemented)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(bool \240)BD(deleteElement)ES( \201const )0 2 A(QString)EA( tag\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(deleteElement)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(tag)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the tag to be deleted in x.y.z notation)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(bool \240)BD(setDomain)ES( \201const )0 2 A(QString)EA( domain, bool overwrite_domain=false\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(setDomain)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(domain)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(domain in simple x[n].y[m].z[p] notation)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(overwrite_domain)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(true if you set a new domain , false if the domain is relative to the old domain)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(bool \240)BD(releaseDomain)ES( \201const )0 2 A(QString)EA( domain\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(releaseDomain)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(domain)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the domain to be released)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(bool \240)BD(createComment)ES( \201const )0 2 A(QString)EA( tag, const )0 2 A(QString)EA( comment\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(createComment)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(tag)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the tag over where we put the comment)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(comment)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the comment we want to write)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(int \240)BD(readIntSimple)ES( \201const )0 2 A(QString)EA( key\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(readIntSimple)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QString)EA( \240)BD(readStringSimple)ES( \201const )0 2 A(QString)EA( tag\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(readStringSimple)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(long long \240)BD(readSectorSimple)ES( \201const )0 2 A(QString)EA( tag\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(readSectorSimple)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(bool \240)BD(writeSimple)ES( \201const )0 2 A(QString)EA( tag,const )0 2 A(QString)EA( value\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(writeSimple)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(bool \240)BD(writeSimple)ES( \201const )0 2 A(QString)EA( tag,const int value\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(writeSimple)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QDomNode)EA( \240)BD(nodeFromTag)ES( \201const )0 2 A(QString)EA( tag\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(nodeFromTag)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(tag)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the tag we want to find in this document)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QDomNode)EA( \240)BD(find)ES( \201const )0 2 A(QString)EA( tag,const )0 2 A(QDomNode)EA( from, bool anidate=true\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(find)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 2 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(tag)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(the tag name we are looking for)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(from)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(we start looking in this node "inwards")} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(anidate)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(if true we'll search between the children, if false we'll search between the siblings)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QString)EA( \240)BD(discardBracket)ES( \201)0 2 A(QString)EA( token, int *number\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(discardBracket)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()I(token)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(is the QString that we want to parse)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
[0 0 0 0 0 0 [[{()4 Sl()WB()I(number)ES()} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
[{()4 Sl()WB(is the number inside the brackets)} 0 0 0 0 1 1 0 (.) 1 0 5 5 5 5 0 0 0 0 [16#ff 16#ff 16#ff] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QString)EA( \240)BD(lookForward)ES( \201const )0 2 A(QString)EA( tag\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(lookForward)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QString)EA( \240)BD(lookBackward)ES( \201const )0 2 A(QString)EA( tag\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(lookBackward)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QDomElement)EA( \240)BD(nextElement)ES( \201)0 2 A(QDomNode)EA( node\202
)BR()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(nextElement)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QFile)EA( * )BD(f)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(f)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB(int  )BD(mode)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(mode)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QDomDocument)EA( * )BD(doc)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(doc)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QDomNode)EA(  )BD(currentNode)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(currentNode)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()4 Sl()WB()0 2 A(QDomNode)EA(  )BD(domain)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
[{()4 Sl()WB()0 3 -1 H()BD(domain)ES()EH()} 0 0 0 0 1 1 2 (.) 2 0 8 8 2 6 0 0 0 0 [16#ee 16#ee 16#ee] 0 ]
]]
]]
] D
0 1 54{TS}for RC ZF
/Ba f D /BO 0 D Bs
/UR (XmlConfig.html) D
/Ti (class XmlConfig) D
/Au () D
/Df f D
/ME [()] D

/Cb [16#ff 16#ff 16#ff] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#ff] D /CL -1 D Ct Sc
Pt

/Ba f D /BO 0 D Bs
/UR (XmlConfig.html) D
/Ti (class XmlConfig) D
/Au () D
/Df f D
/ME [()] D

NP RC ZF
()4 Sl()WB 0 Sn(
)3 PT(
)0 4 0 H(Public)WB 67 Sn( Methods)EH()UL()-1 LI(\240)BD()0 3 1 A(XmlConfig)3 0 TN TL()Ec /AF f D()ES( \201)0 2 A(QString)EA( file, int mode=IO_ReadOnly\202 
)-1 LI(\240)BD()0 5 1 A(~XmlConfig)5 0 TN TL()Ec /AF f D()ES( \201\202 
)-1 LI(int \240)BD()0 7 1 A(howManyTags)7 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag\202 
)-1 LI(int \240)BD()0 9 1 A(howManyAtributes)9 0 TN TL()Ec /AF f D()ES( \201)0 2 A(QString)EA( tag\202 
)-1 LI(bool \240)BD()0 11 1 A(save)11 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( file=nullptr\202 
)-1 LI()0 2 A(QDomDocument)EA( \240)BD()0 13 1 A(cloneDocument)13 0 TN TL()Ec /AF f D()ES( \201\202 
)-1 LI()0 2 A(QString)EA( \240)BD()0 15 1 A(file)15 0 TN TL()Ec /AF f D()ES( \201\202 
)-1 LI()0 2 A(QString)EA( \240)BD()0 17 1 A(readString)17 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag\202 
)-1 LI(int \240)BD()0 19 1 A(readInt)19 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( key\202 
)-1 LI(bool \240)BD()0 21 1 A(write)21 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag,const )0 2 A(QString)EA( value\202 
)-1 LI(bool \240)BD()0 22 1 A(write)22 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag,const int value\202 
)-1 LI(bool \240)BD()0 24 1 A(doWrite)24 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag, const )0 2 A(QString)EA( value\202 
)-1 LI(bool \240)BD()0 25 1 A(doWrite)25 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag, const int value\202 
)-1 LI(bool \240)BD()0 27 1 A(createElement)27 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( node_name, const )0 2 A(QString)EA( value=nullptr, const )0 2 A(QString)EA( comment=nullptr\202 
)-1 LI(bool \240)BD()0 29 1 A(deleteElement)29 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag\202 
)-1 LI(bool \240)BD()0 31 1 A(setDomain)31 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( domain, bool overwrite_domain=false\202 
)-1 LI(bool \240)BD()0 33 1 A(releaseDomain)33 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( domain\202 
)-1 LI(bool \240)BD()0 35 1 A(createComment)35 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag, const )0 2 A(QString)EA( comment\202 
)-1 LI(int \240)BD()0 37 1 A(readIntSimple)37 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( key\202 
)-1 LI()0 2 A(QString)EA( \240)BD()0 39 1 A(readStringSimple)39 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag\202 
)-1 LI(long long \240)BD()0 41 1 A(readSectorSimple)41 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag\202 
)-1 LI(bool \240)BD()0 43 1 A(writeSimple)43 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag,const )0 2 A(QString)EA( value\202 
)-1 LI(bool \240)BD()0 44 1 A(writeSimple)44 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag,const int value\202 )LU()0 4 1 H(Private)WB 68 Sn( Methods)EH()UL()-1 LI()0 2 A(QDomNode)EA( \240)BD()0 46 1 A(nodeFromTag)46 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag\202 
)-1 LI()0 2 A(QDomNode)EA( \240)BD()0 48 1 A(find)48 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag,const )0 2 A(QDomNode)EA( from, bool anidate=true\202 
)-1 LI()0 2 A(QString)EA( \240)BD()0 50 1 A(discardBracket)50 0 TN TL()Ec /AF f D()ES( \201)0 2 A(QString)EA( token, int *number\202 
)-1 LI()0 2 A(QString)EA( \240)BD()0 52 1 A(lookForward)52 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag\202 
)-1 LI()0 2 A(QString)EA( \240)BD()0 54 1 A(lookBackward)54 0 TN TL()Ec /AF f D()ES( \201const )0 2 A(QString)EA( tag\202 
)-1 LI()0 2 A(QDomElement)EA( \240)BD()0 56 1 A(nextElement)56 0 TN TL()Ec /AF f D()ES( \201)0 2 A(QDomNode)EA( node\202 )LU()0 4 2 H(Private)WB 69 Sn( Members)EH()UL()-1 LI(QFile *)BD()0 58 1 A(f)58 0 TN TL()Ec /AF f D()ES(
)-1 LI(int )BD()0 60 1 A(mode)60 0 TN TL()Ec /AF f D()ES(
)-1 LI(QDomDocument *)BD()0 62 1 A(doc)62 0 TN TL()Ec /AF f D()ES(
)-1 LI(QDomNode )BD()0 64 1 A(currentNode)64 0 TN TL()Ec /AF f D()ES(
)-1 LI(QDomNode )BD()0 66 1 A(domain)66 0 TN TL()Ec /AF f D()ES()LU()2 1 1 HR()0 2 3 H(Detailed)WB 70 Sn()WB 1 Sn( Description)EA()EH()0 P()EP(
)WB 2 Sn()EA()WB 3 Sn()EA()4 PT()0 P()EP()0 P( CONSTRUCTOR
 We make the xml document from the file. So we can close the file, we have all the info
 in doc, we only deal with Xml clases from now on.)EP(
)0 P()EP(
)0 P()EP(
)0 P()BD(Parameters)ES(:)5 PT()EP(
)WB 4 Sn()EA()WB 5 Sn()EA()6 PT()0 P()EP()0 P( DESTRUCTOR
 Nothing to be done, qt cares about freeing dom objects memory when we die
 )EP(
)WB 6 Sn()EA()WB 7 Sn()EA()7 PT()0 P()EP()0 P()EP(
)0 P()BD(Parameters)ES(:)8 PT()EP(
)0 P()BD(Returns)ES(: the number of tags with name tag  in the domain domain
 )EP(
)WB 8 Sn()EA()WB 9 Sn()EA()9 PT()0 P()EP()0 P( how many atributes has a tag, useful to navigate between the atributes)EP(
)0 P()BD(Parameters)ES(:)10 PT()EP(
)0 P()BD(Returns)ES(: the number of atributes of tag
 )EP(
)WB 10 Sn()EA()WB 11 Sn()EA()11 PT()0 P()EP()0 P( Saves the xml data in a file named file and flush it to disk.
 If the filename is null it will write the data to the same file it reads
 it from. Note that the constructor of this object needs to be said
 explicitely that you want to save data with IO_ReadWrite )EP(
)0 P()BD(Parameters)ES(:)12 PT()EP(
)0 P()BD(Returns)ES(: true if success or false otherwise
 )EP(
)WB 12 Sn()EA()WB 13 Sn()EA()13 PT()0 P()EP()0 P( it's useful to be called from the constructor that will make a new xmlconfig object with the
 same data but not necesary accesed in the same way, so
 you can write to the file afterwards. With the same or other name
 The changes in this xmlconfig data will not affect the other xmlconfig data)EP(
)0 P()BD(Returns)ES(: the entire xml document
  )EP(
)WB 14 Sn()EA()WB 15 Sn()EA()14 PT()0 P()EP()0 P( return the name of the file  we have taken the data from
 if we save the data in other file, this method will return the name
 of the new file
 In short, it returns the name of the representation of the data
 in disk \201surely not updated\202)EP(
)0 P()BD(Returns)ES(: the name of the file
 )EP(
)WB 16 Sn()EA()WB 17 Sn()EA()15 PT()0 P()EP()0 P( The general form of the tag is  "x[n].y[m].z[p]" We look for the string in the xml doc
 the string must be unique or we will just return the first one we find.
 The numbers are known thanks to howManyTags\201\202;
 TODO?: it's trivial to implement a way to detect a non-unique string so we can return the error but
 it will require other param)EP(
)0 P()BD(Parameters)ES(:)16 PT()EP(
)0 P()BD(Returns)ES(: the data from the tag with name tag
 )EP(
)WB 18 Sn()EA()WB 19 Sn()EA()17 PT()0 P()EP()0 P()EP(
)0 P()BD(Returns)ES(: the integer in the string, integer is a very common type so it's worthy
  )EP(
)WB 20 Sn()EA()WB 21 Sn()EA()18 PT()0 P()EP()0 P( Writes the value value in the tag tag , it's done in memory if you want to modify the
 file .save\201\202 must be called to sync data with disk)EP(
)0 P()BD(Parameters)ES(:)19 PT()EP(
)0 P()BD(Returns)ES(: true if succesfull , false otherwhise \201false if the tag don't exist\202
 )EP(
)WB 20 Sn()EA()WB 22 Sn()EA()20 PT()0 P()EP()0 P( Same as above, writes a integer in the xml configuration)EP(
)0 P()BD(Parameters)ES(:)21 PT()EP(
)0 P()BD(Returns)ES(: true if succesfull , false otherwhise
 )EP(
)WB 23 Sn()EA()WB 24 Sn()EA()22 PT()0 P()EP()0 P( The same that write but if the tag dont exist it will create it and write the value)EP(
)0 P()BD(Parameters)ES(:)23 PT()EP(
)0 P()BD(Returns)ES(: true if succesfull false otherwise
  )EP(
)WB 23 Sn()EA()WB 25 Sn()EA()24 PT()0 P()EP()0 P( A convenient function, lots of times, we'll write int)EP(
)0 P()BD(Parameters)ES(:)25 PT()EP(
)0 P()BD(Returns)ES(: true if succesfull false otherwise
  )EP(
)WB 26 Sn()EA()WB 27 Sn()EA()26 PT()0 P()EP()0 P( This will create a new Element in the xml taking the root as the
 jail we are in , we have the x[].y[].z[] notation again.
 This will create a  value  in the xml doc
 The comment is absolutely optional
 The node will be written in the position marked with [n] or in the LAST position
 if no [n] specified)EP(
)0 P()BD(Parameters)ES(:)27 PT()EP(
)0 P()BD(Returns)ES(: true if success false if fail.
 )EP(
)WB 28 Sn()EA()WB 29 Sn()EA()28 PT()0 P()EP()0 P( This will delete a element  tag value 
 also note that this can delete a big amount of info as
  infoinfo<  info)EA(  deleting "a" here
 will delete all the children tags)EP(
)0 P()BD(Parameters)ES(:)29 PT()EP(
)0 P()BD(Returns)ES(: true if succesful , false if not found
 )EP(
)WB 30 Sn()EA()WB 31 Sn()EA()30 PT()0 P()EP()0 P( Limit the scope of all the operations to the domain in domain
 This make the reads/writes more efficient but are not in any way
 necesary so you can just ignore setDomain and releaseDomain
 in your application
 note that as you enter in a jail when using this function you must
 take care about exiting from it using releaseDomain
 you can anidate domains, setDomain\201a\202 ; setDomain \201b\202 will set the domain to
 a.b and so on
 note that you can say if the domain you are setting is global \201relative to the document\202
 or relative to the current domain, so :
 setDomain\201"a.b.c", true\202; is the same that
 setDomain\201"a"\202; setDomain\201b\202; setDomain\201c\202;)EP(
)0 P()BD(Parameters)ES(:)31 PT()EP(
)0 P()BD(Returns)ES(: true if success , false when fails.
 )EP(
)WB 32 Sn()EA()WB 33 Sn()EA()32 PT()0 P()EP()0 P( Just release the jail the setDomain\201\202 enter us in, read the
 setDomain comment
 the domain must be a simple string no need to specify [] as we take
 care of releasing just what was set.
 for instance:
 setDomain \201"disk[1].partition[2].geometry"\202
 releaseDomain\201"geometry"\202; will let the domain set to disk[1].partition[2]
 releaseDomain\201"partition"\202;  will let the domain set to disk[1]
 releaseDomain\201"disk"\202;  will eliminate the jail at all)EP(
)0 P()BD(Parameters)ES(:)33 PT()EP(
)0 P()BD(Returns)ES(: true if successful
 )EP(
)WB 34 Sn()EA()WB 35 Sn()EA()34 PT()0 P()EP()0 P( It will create a comment just over the tag tag
 the comments are not parsed with this API, so you can't change
 nor delete them \201not yet\202)EP(
)0 P()BD(Parameters)ES(:)35 PT()EP(
)0 P()BD(Returns)ES(: true if succesful , false otherwise
  )EP(
)WB 36 Sn()EA()WB 37 Sn()EA()36 PT()0 P()EP()0 P( API 2
 The simple methods will access in a herarquical way.
 This methods are going to die, just leaving it in case the other way of doing things
 turns on complex code.
 We must not use it as it will be removed.
 )EP(
)WB 38 Sn()EA()WB 39 Sn()EA()37 PT()0 P()EP()0 P( API 2
 Looks for the string in the XML file and returns the value asociated to it
  )EP(
)WB 40 Sn()EA()WB 41 Sn()EA()38 PT()0 P()EP()0 P( API 2
 The same as above, it returns a sector
 )EP(
)WB 42 Sn()EA()WB 43 Sn()EA()39 PT()0 P()EP()0 P( API 2
 Writes a value in the Xml tag with name key.
 In case this node "don't have space" \201it just have other tags, no values\202
 It will enter this level so the next time we try to read/write will do it here
 Note that this means that the XML file tags MUST EXIST even if they have void data
 It also means that when you enter a level you must be careful because if you look for
 something outside it you'll go out so you'll have to enter again.
 The aim is that this never happens so the code seems pretty natural, and easy to follow.)EP(
)0 P()BD(Returns)ES(: true if success or false otherwhise
  )EP(
)WB 42 Sn()EA()WB 44 Sn()EA()40 PT()0 P()EP()0 P( API 2
  Same as above, writes a integer in the xml configuration )EP(
)WB 45 Sn()EA()WB 46 Sn()EA()41 PT()0 P( )2 FZ([private])ES()EP()0 P( This method finds a node from a tag  name. It understand the x[n].y[m].z[p]
 thing and will be used everywhere)EP(
)0 P()BD(Parameters)ES(:)42 PT()EP(
)0 P()BD(Returns)ES(: the node in the document with this tag as name)EP(
)WB 47 Sn()EA()WB 48 Sn()EA()43 PT()0 P( )2 FZ([private])ES()EP()0 P( Helper function  for nodeFromTag. It just return the first node found.
 We first look all the siblings and then begin to enter in the next level so
 in the end we must have walked the entire tree. It's not very efficent for now.)EP(
)0 P()BD(Parameters)ES(:)44 PT()EP(
)0 P()BD(Returns)ES(: the first node with this node found)EP(
)WB 49 Sn()EA()WB 50 Sn()EA()45 PT()0 P( )2 FZ([private])ES()EP()0 P( Yet another helper method, it accepts a string  token[number]
 and returns token and number with no [ ].)EP(
)0 P()BD(Parameters)ES(:)46 PT()EP(
)0 P()BD(Returns)ES(: the parsed string)EP(
)WB 51 Sn()EA()WB 52 Sn()EA()47 PT()0 P( )2 FZ([private])ES()EP()0 P( API 2
 Looks in the same level from the current node to the end, if doesn't
find anything just return null, else it modifies the current node and
return the text found )EP(
)WB 53 Sn()EA()WB 54 Sn()EA()48 PT()0 P( )2 FZ([private])ES()EP()0 P( API 2
Looks backwards in the same level from the current node to the end, if doesn't
find anything just return null, else it modifies the current node and
return the text found )EP(
)WB 55 Sn()EA()WB 56 Sn()EA()49 PT()0 P( )2 FZ([private])ES()EP()WB 57 Sn()EA()WB 58 Sn()EA()50 PT()0 P( )2 FZ([private])ES()EP()WB 59 Sn()EA()WB 60 Sn()EA()51 PT()0 P( )2 FZ([private])ES()EP()WB 61 Sn()EA()WB 62 Sn()EA()52 PT()0 P( )2 FZ([private])ES()EP()WB 63 Sn()EA()WB 64 Sn()EA()53 PT()0 P( )2 FZ([private])ES()EP()WB 65 Sn()EA()WB 66 Sn()EA()54 PT()0 P( )2 FZ([private])ES()EP()2 1 1 HR()UL()-1 LI()I(Version)ES(: 0.1
 This class will deal with the configuration stored in the XML file
 When a class wants to know the configuration stored or wants to store his own
 it just write and read in this object.
 The aim of the class is to be very easy to work with.
 It provides two different APIs , API 1 and API 2 \201original names isn't it?\202
 API 1  This is the API that must be used, it's supposed to work
 The general form of the tag is  "x[n].y[m].z[p]" We look for the string in the xml doc
 the string must be unique or we will just return the first one we find.
 The numbers are known thanks to howManyTags\201\202;
 API 2 is the *Simple functions, if they are not needed will be deprecated and deleted 
 from this object
 )-1 LI()I(Generated)ES(: jordi on shadow on Sat Jun  8 11:58:11 2002, using kdoc 2.0a54.)LU(
)WB NL /BO 0 D TC /Ba f D Bs /AU f D /UR () D RC ZF
tH WB
ND 1 gt{Ts 3 mul Np 0()0 C()BD(class XmlConfig)ES()0 1 TN()EA()BN}if
4 NH le{67(0.0.0.1\240\240)4 C(Public Methods)67 1 TN()EA()BN}if
4 NH le{68(0.0.0.2\240\240)4 C(Private Methods)68 1 TN()EA()BN}if
4 NH le{69(0.0.0.3\240\240)4 C(Private Members)69 1 TN()EA()BN}if
2 NH le{70(0.1\240\240)2 C(Detailed)WB 1 Sn( Description)70 1 TN()EA()BN}if

/TE t D NP TU PM 0 eq and{/Pn () D showpage}if end restore
